/**
// Copyright (C) 2011,2012 pdfcrowd.com
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// @author vanchester
// @site vanchester.ru
// @about Reversed official tool for use service bypass paid API
*/

var https = require("https"),
	XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest,
	fs = require("fs");


var Pdfcrowd = function(username, apikey, host) {
	this.username = username || '';
	this.apikey = apikey || '';
	this.host = host || 'pdfcrowd.com';
};


//
// Converts a web page
//
Pdfcrowd.prototype.convertURI = function (uri, callbacks) {
	if (!uri) throw 'convertURI: invalid URL.';
	requestQueue.addRequest([this, {
		src: uri,
		endpoint: '/form/json/convert/uri/',
		callbacks: prepareCallbacks(callbacks)
	}]);
};

//
// Returns a callback object that saves the generated PDF to a file
//
var saveToFile = function (fname) {
	return {
		pdf: function (rstream) {
			wstream = fs.createWriteStream(fname);
			rstream.pipe(wstream);
		},
		error: function (errMessage, statusCode) { console.log("ERROR: " + errMessage); },
		end: function () {}
	};
};

//
// Exports
//
module.exports = {
	Pdfcrowd: Pdfcrowd,
	saveToFile: saveToFile
};





// ---------------------------------------------------------------------------
//								PRIVATE

//
// Adds the default implementation if a callback is missing
//
var prepareCallbacks = function (callbacks) {
	callbacks = callbacks || {};
	if (typeof callbacks.pdf !== "function") {
		callbacks.pdf = function(rstream) {
			rstream.destroy();
			console.warn('WARNING: [Pdfcrowd] Unhandled PDF generation.');
		};
	}

	if (typeof callbacks.error !== "function") {
		callbacks.error = function(errMessage, statusCode) {
			console.warn("WARNING: [Pdfcrowd] Unhandled error: %d - %s", statusCode, errMessage);
		};
	}

	if (typeof callbacks.end !== "function") {
		callbacks.end = function() {};
	}

	return callbacks;
};

//
// A global request queue which serializes content calls.
//
var requestQueue = {
	init: function () {
		this.queue = [];
		this.working = 0;
	},

	addRequest: function (req) {
		this.queue.push(req);
		this.processRequest();
	},

	requestDone: function () {
		this.working = 0;
		this.processRequest();
	},

	processRequest: function () {
		if (this.queue.length > 0 && !this.working) {
			this.working = 1;
			var args = this.queue.shift();
			convertInternal.apply(null, args);
		}
	}
};

//
// Calls the API
//
var convertInternal = function (that, opts) {
	var xmlhttp = new XMLHttpRequest();

	xmlhttp.onreadystatechange = function () {
		var callbacks = opts.callbacks;

		if (xmlhttp.readyState !== 4 || xmlhttp.status !== 200 || typeof xmlhttp.responseText !== 'string') {
			return;
		}

		var answer = JSON.parse(xmlhttp.responseText);

		if (typeof answer !== 'object' || answer.status !== 'ok') {
			requestQueue.requestDone();
			return;
		}

		var req = https.get('https://' + that.host + '/' + answer.uri, function (res) {
			if (res.statusCode < 300) {
				res.on('end', function () {
					callbacks.end();
					requestQueue.requestDone();
				});

				res.on('error', function (exc) {
					callbacks.error(exc.toString());
					requestQueue.requestDone();
				});

				callbacks.pdf(res);
			} else {
				var err = [];
				res.on('data', function (chunk) {
					err.push(chunk.toString());
				});
				res.on('end', function () {
					callbacks.error(err.join(''), res.statusCode);
					requestQueue.requestDone();
				});
			}
		});

		req.on('error', function (res) {
			callbacks.error(res.toString(), res.statusCode);
			requestQueue.requestDone();
		});
	};

	xmlhttp.open("POST", "https://" + that.host + opts.endpoint, true);
	xmlhttp.send('noCache=' + (new Date().getTime()) + '&src=' + opts.src + '&conversion_source=uri');
};

requestQueue.init();

